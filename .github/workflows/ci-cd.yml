# .github/workflows/ci-cd.yml
# ==============================================
# ë©€í‹° ì—ì´ì „íŠ¸ ìŠ¤ë§ˆíŠ¸ íŒ©í† ë¦¬ Kubernetes CI/CD íŒŒì´í”„ë¼ì¸
# ==============================================
# 
# ğŸ”„ ì „ì²´ ì‹¤í–‰ íë¦„:
# 1. PR ìƒì„±ì‹œ: quality-check + auto-review ì‹¤í–‰
# 2. main ë¸Œëœì¹˜ í‘¸ì‹œì‹œ: ëª¨ë“  Jobì´ ìˆœì„œëŒ€ë¡œ ì‹¤í–‰
#    - build-and-push (Docker ì´ë¯¸ì§€ ìƒì„±)
#    - deploy-to-aks (AKSì— ë°°í¬) 
#    - health-check (ë°°í¬ ê²€ì¦)
#    - notify (ê²°ê³¼ ì•Œë¦¼)
#
# ğŸ“‹ Job êµ¬ì„±:
# - Job 1: quality-check (ì½”ë“œ í’ˆì§ˆ ê²€ì‚¬)
# - Job 2: build-and-push (Docker ë¹Œë“œ & ACR í‘¸ì‹œ)
# - Job 3: deploy-to-aks (AKS ë°°í¬)
# - Job 4: health-check (í—¬ìŠ¤ì²´í¬)
# - Job 5: auto-review (ìë™ PR ë¦¬ë·°)
# - Job 6: notify (ë°°í¬ ê²°ê³¼ ì•Œë¦¼)
#
name: Multi-Agent Smart Factory CI/CD Pipeline for Kubernetes

# íŠ¸ë¦¬ê±° ì¡°ê±´: PR ìƒì„±ì‹œ ë˜ëŠ” main ë¸Œëœì¹˜ í‘¸ì‹œì‹œ ì‹¤í–‰
on:
  pull_request:
    branches: [ main ]    # main ë¸Œëœì¹˜ë¡œ PR ìƒì„±ì‹œ ì‹¤í–‰
  push:
    branches: [ main ]    # main ë¸Œëœì¹˜ì— í‘¸ì‹œì‹œ ì‹¤í–‰

# GitHub Actions ê¶Œí•œ ì„¤ì •
permissions:
  contents: read          # ì½”ë“œ ì½ê¸° ê¶Œí•œ
  pull-requests: write    # PR ëŒ“ê¸€ ì‘ì„± ê¶Œí•œ
  checks: write          # ì²´í¬ ìƒíƒœ ì—…ë°ì´íŠ¸ ê¶Œí•œ
  actions: read          # Actions ê²°ê³¼ ì½ê¸° ê¶Œí•œ
  packages: write        # íŒ¨í‚¤ì§€(ì´ë¯¸ì§€) ì—…ë¡œë“œ ê¶Œí•œ
  id-token: write        # Azure ì¸ì¦ í† í° ê¶Œí•œ

# ì „ì—­ í™˜ê²½ë³€ìˆ˜ (ëª¨ë“  Jobì—ì„œ ì‚¬ìš©)
env:
  REGISTRY: 23acr.azurecr.io              # Azure Container Registry ì£¼ì†Œ
  AKS_CLUSTER_NAME: 23-aks                # AKS í´ëŸ¬ìŠ¤í„° ì´ë¦„
  AKS_RESOURCE_GROUP: 23-rsrc             # Azure ë¦¬ì†ŒìŠ¤ ê·¸ë£¹
  IMAGE_NAME: multi-agent-smart-factory   # Docker ì´ë¯¸ì§€ ì´ë¦„
  NAMESPACE: smart-factory                # Kubernetes ë„¤ì„ìŠ¤í˜ì´ìŠ¤

jobs:
  # ==============================================
  # Job 1: ì½”ë“œ í’ˆì§ˆ ê²€ì‚¬ (PRì¼ ë•Œë§Œ ì‹¤í–‰)
  # ==============================================
  quality-check:
    if: github.event_name == 'pull_request'  # PRì¼ ë•Œë§Œ ì‹¤í–‰
    runs-on: ubuntu-latest                   # Ubuntu ìµœì‹  ë²„ì „ì—ì„œ ì‹¤í–‰
    # ë‹¤ë¥¸ Jobì—ì„œ ì‚¬ìš©í•  ê²°ê³¼ê°’ë“¤ ì •ì˜
    outputs:
      total_tests: ${{ steps.test.outputs.total_tests }}    # ì „ì²´ í…ŒìŠ¤íŠ¸ ìˆ˜
      passed_tests: ${{ steps.test.outputs.passed_tests }}  # í†µê³¼í•œ í…ŒìŠ¤íŠ¸ ìˆ˜
      failed_tests: ${{ steps.test.outputs.failed_tests }}  # ì‹¤íŒ¨í•œ í…ŒìŠ¤íŠ¸ ìˆ˜
      skipped_tests: ${{ steps.test.outputs.skipped_tests }} # ê±´ë„ˆë›´ í…ŒìŠ¤íŠ¸ ìˆ˜
      coverage: ${{ steps.test.outputs.coverage }}          # ì½”ë“œ ì»¤ë²„ë¦¬ì§€ %
      lint_errors: ${{ steps.lint.outputs.lint_errors }}    # ë¦°íŠ¸ ì—ëŸ¬ ìˆ˜
      high_issues: ${{ steps.security.outputs.high_issues }} # ë†’ì€ ì‹¬ê°ë„ ë³´ì•ˆ ì´ìŠˆ
      medium_issues: ${{ steps.security.outputs.medium_issues }} # ì¤‘ê°„ ì‹¬ê°ë„ ë³´ì•ˆ ì´ìŠˆ
      low_issues: ${{ steps.security.outputs.low_issues }}  # ë‚®ì€ ì‹¬ê°ë„ ë³´ì•ˆ ì´ìŠˆ
      total_issues: ${{ steps.security.outputs.total_issues }} # ì „ì²´ ë³´ì•ˆ ì´ìŠˆ

    steps:
      # 1. ì½”ë“œ ì²´í¬ì•„ì›ƒ (GitHubì—ì„œ ì½”ë“œ ë‹¤ìš´ë¡œë“œ)
      - uses: actions/checkout@v4

      # 2. Python 3.10 ì„¤ì¹˜
      - name: Set up Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      # 3. pip ì˜ì¡´ì„± ìºì‹± (ë¹Œë“œ ì†ë„ í–¥ìƒ)
      - name: Cache pip dependencies
        uses: actions/cache@v3
        with:
          path: ~/.cache/pip                                      # ìºì‹œ ì €ì¥ ê²½ë¡œ
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}  # ìºì‹œ í‚¤
          restore-keys: |
            ${{ runner.os }}-pip-

      # 4. ì˜ì¡´ì„± ì„¤ì¹˜
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip    # pip ì—…ê·¸ë ˆì´ë“œ
          pip install -r requirements.txt       # í”„ë¡œì íŠ¸ ì˜ì¡´ì„± ì„¤ì¹˜
          pip install pytest pytest-cov flake8 mypy bandit  # í…ŒìŠ¤íŠ¸/ê²€ì‚¬ ë„êµ¬ ì„¤ì¹˜

      # 5. Flake8ë¡œ ì½”ë“œ ìŠ¤íƒ€ì¼ ê²€ì‚¬
      - name: Linting with Flake8
        id: lint    # ë‹¤ë¥¸ ë‹¨ê³„ì—ì„œ ì°¸ì¡°í•  ìˆ˜ ìˆë„ë¡ ID ì„¤ì •
        run: |
          # ì‹¬ê°í•œ ì—ëŸ¬ë§Œ ì²´í¬ (E9, F63, F7, F82)
          flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics > flake8-results.txt 2>&1 || true
          # ì—ëŸ¬ ê°œìˆ˜ ì„¸ê¸°
          LINT_ERRORS=$(grep -c "E9\|F63\|F7\|F82" flake8-results.txt 2>/dev/null || echo "0")
          # GitHub Actions ì¶œë ¥ì— ì €ì¥ (ë‹¤ë¥¸ Jobì—ì„œ ì‚¬ìš© ê°€ëŠ¥)
          echo "lint_errors=${LINT_ERRORS}" >> $GITHUB_OUTPUT
          
          # ì „ì²´ ìŠ¤íƒ€ì¼ ì²´í¬ (ìµœëŒ€ ì¤„ ê¸¸ì´ 120ì)
          flake8 . --count --max-line-length=120 --statistics >> flake8-results.txt 2>&1 || true

      # 6. MyPyë¡œ íƒ€ì… ê²€ì‚¬
      - name: Type checking with MyPy
        continue-on-error: true    # íƒ€ì… ì—ëŸ¬ê°€ ìˆì–´ë„ ê³„ì† ì§„í–‰
        run: |
          mypy . --ignore-missing-imports --no-strict-optional || true

      # 7. pytestë¡œ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ë° ì»¤ë²„ë¦¬ì§€ ì¸¡ì •
      - name: Run tests with coverage
        id: test
        run: |
          # í…ŒìŠ¤íŠ¸ íŒŒì¼ì´ ìˆëŠ”ì§€ í™•ì¸
          if find . -name "test_*.py" -o -name "*_test.py" | grep -q .; then
            # pytest ì‹¤í–‰ (ì»¤ë²„ë¦¬ì§€ ì¸¡ì •, XML ë¦¬í¬íŠ¸ ìƒì„±)
            pytest --cov=. --cov-report=xml --cov-report=term-missing --junitxml=test-results.xml -v || true
            
            # í…ŒìŠ¤íŠ¸ ê²°ê³¼ XML íŒŒì‹±
            if [ -f test-results.xml ]; then
              # ì •ê·œí‘œí˜„ì‹ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ ìˆ˜ ì¶”ì¶œ
              TOTAL=$(grep -o 'tests="[^"]*"' test-results.xml | grep -o '[0-9]*' || echo "0")
              FAILURES=$(grep -o 'failures="[^"]*"' test-results.xml | grep -o '[0-9]*' || echo "0")
              ERRORS=$(grep -o 'errors="[^"]*"' test-results.xml | grep -o '[0-9]*' || echo "0")
              SKIPPED=$(grep -o 'skipped="[^"]*"' test-results.xml | grep -o '[0-9]*' || echo "0")
              PASSED=$((TOTAL - FAILURES - ERRORS))  # í†µê³¼í•œ í…ŒìŠ¤íŠ¸ = ì „ì²´ - ì‹¤íŒ¨ - ì—ëŸ¬
            else
              TOTAL=0; PASSED=0; FAILURES=0; ERRORS=0; SKIPPED=0
            fi
            
            # ì»¤ë²„ë¦¬ì§€ % ê³„ì‚°
            if [ -f coverage.xml ]; then
              COVERAGE=$(grep -o 'line-rate="[^"]*"' coverage.xml | head -1 | grep -o '[0-9.]*' | awk '{print int($1*100)}' || echo "0")
            else
              COVERAGE="0"
            fi
          else
            echo "No tests found"
            TOTAL=0; PASSED=0; FAILURES=0; ERRORS=0; SKIPPED=0; COVERAGE="0"
          fi
          
          # ê²°ê³¼ë¥¼ GitHub Actions ì¶œë ¥ì— ì €ì¥
          echo "total_tests=$TOTAL" >> $GITHUB_OUTPUT
          echo "passed_tests=$PASSED" >> $GITHUB_OUTPUT
          echo "failed_tests=$((FAILURES + ERRORS))" >> $GITHUB_OUTPUT
          echo "skipped_tests=$SKIPPED" >> $GITHUB_OUTPUT
          echo "coverage=$COVERAGE" >> $GITHUB_OUTPUT

      # 8. Banditìœ¼ë¡œ ë³´ì•ˆ ìŠ¤ìº”
      - name: Security scan with Bandit
        id: security
        run: |
          # ë³´ì•ˆ ìŠ¤ìº” ì‹¤í–‰ (JSON í˜•íƒœë¡œ ê²°ê³¼ ì €ì¥)
          bandit -r . -f json -o bandit-report.json || true
          
          # jqë¡œ JSON íŒŒì‹±í•´ì„œ ì‹¬ê°ë„ë³„ ì´ìŠˆ ê°œìˆ˜ ê³„ì‚°
          if [ -f bandit-report.json ]; then
            HIGH=$(jq '[.results[] | select(.issue_severity=="HIGH")] | length' bandit-report.json || echo "0")
            MEDIUM=$(jq '[.results[] | select(.issue_severity=="MEDIUM")] | length' bandit-report.json || echo "0")
            LOW=$(jq '[.results[] | select(.issue_severity=="LOW")] | length' bandit-report.json || echo "0")
            TOTAL=$((HIGH + MEDIUM + LOW))
          else
            HIGH=0; MEDIUM=0; LOW=0; TOTAL=0
          fi

          # ê²°ê³¼ë¥¼ GitHub Actions ì¶œë ¥ì— ì €ì¥
          echo "high_issues=$HIGH" >> $GITHUB_OUTPUT
          echo "medium_issues=$MEDIUM" >> $GITHUB_OUTPUT
          echo "low_issues=$LOW" >> $GITHUB_OUTPUT
          echo "total_issues=$TOTAL" >> $GITHUB_OUTPUT

      # 9. í…ŒìŠ¤íŠ¸ ê²°ê³¼ íŒŒì¼ë“¤ì„ ì•„í‹°íŒ©íŠ¸ë¡œ ì—…ë¡œë“œ
      - name: Upload test and security results
        uses: actions/upload-artifact@v4
        with:
          name: test-and-security-results
          path: |
            test-results.xml      # í…ŒìŠ¤íŠ¸ ê²°ê³¼
            coverage.xml          # ì»¤ë²„ë¦¬ì§€ ê²°ê³¼
            flake8-results.txt   # ë¦°íŠ¸ ê²°ê³¼
            bandit-report.json   # ë³´ì•ˆ ìŠ¤ìº” ê²°ê³¼

  # ==============================================
  # Job 2: Docker ë¹Œë“œ ë° ACR í‘¸ì‹œ (main ë¸Œëœì¹˜ë§Œ)
  # ==============================================
  build-and-push:
    if: github.ref == 'refs/heads/main'    # main ë¸Œëœì¹˜ì¼ ë•Œë§Œ ì‹¤í–‰
    runs-on: ubuntu-latest
    needs: []                              # ë‹¤ë¥¸ Job ê¸°ë‹¤ë¦¬ì§€ ì•Šê³  ë°”ë¡œ ì‹¤í–‰
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}      # ìƒì„±ëœ ì´ë¯¸ì§€ íƒœê·¸
      image-digest: ${{ steps.build.outputs.digest }} # ì´ë¯¸ì§€ í•´ì‹œê°’

    steps:
      # 1. ì½”ë“œ ì²´í¬ì•„ì›ƒ
      - uses: actions/checkout@v4

      # 2. Docker Buildx ì„¤ì • (ë©€í‹° í”Œë«í¼ ë¹Œë“œ ì§€ì›)
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # 3. Azure Container Registry ë¡œê·¸ì¸
      - name: Log in to Azure Container Registry
        uses: azure/docker-login@v1
        with:
          login-server: ${{ env.REGISTRY }}        # 23acr.azurecr.io
          username: ${{ secrets.ACR_USERNAME }}    # GitHub Secretsì—ì„œ ê°€ì ¸ì˜´
          password: ${{ secrets.ACR_PASSWORD }}    # GitHub Secretsì—ì„œ ê°€ì ¸ì˜´

      # 4. Docker ì´ë¯¸ì§€ ë©”íƒ€ë°ì´í„° ìƒì„± (íƒœê·¸ ë“±)
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}    # 23acr.azurecr.io/multi-agent-smart-factory
          tags: |
            type=ref,event=branch                    # ë¸Œëœì¹˜ëª…ìœ¼ë¡œ íƒœê·¸
            type=ref,event=pr                        # PR ë²ˆí˜¸ë¡œ íƒœê·¸  
            type=sha,prefix={{branch}}-              # ë¸Œëœì¹˜ëª…-SHAë¡œ íƒœê·¸
            type=raw,value=latest,enable={{is_default_branch}}  # main ë¸Œëœì¹˜ë©´ latest íƒœê·¸
            type=raw,value=prod-{{date 'YYYYMMDD-HHmmss'}}     # í”„ë¡œë•ì…˜ íƒ€ì„ìŠ¤íƒ¬í”„ íƒœê·¸

      # 5. Docker ì´ë¯¸ì§€ ë¹Œë“œ ë° í‘¸ì‹œ
      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .                              # í˜„ì¬ ë””ë ‰í„°ë¦¬ì—ì„œ ë¹Œë“œ
          platforms: linux/amd64                 # AMD64 í”Œë«í¼ìš©ìœ¼ë¡œ ë¹Œë“œ
          push: true                              # ë¹Œë“œ í›„ ë ˆì§€ìŠ¤íŠ¸ë¦¬ì— í‘¸ì‹œ
          tags: ${{ steps.meta.outputs.tags }}   # ìœ„ì—ì„œ ìƒì„±í•œ íƒœê·¸ë“¤ ì‚¬ìš©
          labels: ${{ steps.meta.outputs.labels }} # ë©”íƒ€ë°ì´í„° ë¼ë²¨
          cache-from: type=gha                    # GitHub Actions ìºì‹œì—ì„œ ì½ê¸°
          cache-to: type=gha,mode=max            # GitHub Actions ìºì‹œì— ì €ì¥
          build-args: |                          # ë¹Œë“œ ì‹œ ì „ë‹¬í•  ì¸ìˆ˜ë“¤
            ENVIRONMENT=production
            VERSION=${{ github.sha }}             # Git ì»¤ë°‹ SHA

  # ==============================================
  # Job 3: AKS ë°°í¬ (ë¹Œë“œ ì™„ë£Œ í›„ ì‹¤í–‰)
  # ==============================================
  deploy-to-aks:
    if: github.ref == 'refs/heads/main'      # main ë¸Œëœì¹˜ì¼ ë•Œë§Œ
    needs: [build-and-push]                  # ë¹Œë“œ ì™„ë£Œ í›„ ì‹¤í–‰
    runs-on: ubuntu-latest
    environment: production                   # production í™˜ê²½ ì„¤ì •

    steps:
      # 1. ì½”ë“œ ì²´í¬ì•„ì›ƒ
      - uses: actions/checkout@v4

      # 2. Azure ë¡œê·¸ì¸
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}  # Service Principal JSON

      # 3. AKS í´ëŸ¬ìŠ¤í„° ìê²©ì¦ëª… ê°€ì ¸ì˜¤ê¸°
      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AKS_RESOURCE_GROUP }} \    # 23-rsrc
            --name ${{ env.AKS_CLUSTER_NAME }} \                # 23-aks
            --overwrite-existing                                # ê¸°ì¡´ ì„¤ì • ë®ì–´ì“°ê¸°

      # 4. kubectl ì„¤ì¹˜
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'

      # 5. ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ìƒì„± (ì—†ìœ¼ë©´ ìƒì„±, ìˆìœ¼ë©´ ë¬´ì‹œ)
      - name: Create namespace if not exists
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      # 6. Kubernetes Secrets ìƒì„±
      - name: Create secrets
        run: |
          # ê¸°ì¡´ ì‹œí¬ë¦¿ ì‚­ì œ (ì—ëŸ¬ ë¬´ì‹œ)
          kubectl delete secret smart-factory-secrets -n ${{ env.NAMESPACE }} --ignore-not-found=true
          kubectl delete secret acr-secret -n ${{ env.NAMESPACE }} --ignore-not-found=true
          
          # ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œí¬ë¦¿ ìƒì„± (API í‚¤, DB ì •ë³´ ë“±)
          kubectl create secret generic smart-factory-secrets \
            --from-literal=OPENAI_API_KEY="${{ secrets.OPENAI_API_KEY }}" \
            --from-literal=GOOGLE_API_KEY="${{ secrets.GOOGLE_API_KEY }}" \
            --from-literal=CLOVA_API_KEY="${{ secrets.CLOVA_API_KEY }}" \
            --from-literal=CLOVA_API_SECRET="${{ secrets.CLOVA_API_SECRET }}" \
            --from-literal=DATABASE_URL="${{ secrets.DATABASE_URL }}" \
            --from-literal=REDIS_URL="${{ secrets.REDIS_URL }}" \
            --from-literal=KAFKA_BOOTSTRAP_SERVERS="${{ secrets.KAFKA_BOOTSTRAP_SERVERS }}" \
            --from-literal=SECRET_KEY="${{ secrets.SECRET_KEY }}" \
            --from-literal=ADMIN_API_KEY="${{ secrets.ADMIN_API_KEY }}" \
            --from-literal=USER_API_KEY="${{ secrets.USER_API_KEY }}" \
            -n ${{ env.NAMESPACE }}
          
          # Docker ë ˆì§€ìŠ¤íŠ¸ë¦¬ ì ‘ê·¼ìš© ì‹œí¬ë¦¿ ìƒì„±
          kubectl create secret docker-registry acr-secret \
            --docker-server=${{ env.REGISTRY }} \              # 23acr.azurecr.io
            --docker-username=${{ secrets.ACR_USERNAME }} \
            --docker-password=${{ secrets.ACR_PASSWORD }} \
            -n ${{ env.NAMESPACE }}

      # 7. ConfigMap ë°°í¬
      - name: Deploy ConfigMap
        run: |
          envsubst < k8s/configmap.yaml | kubectl apply -f -   # í™˜ê²½ë³€ìˆ˜ ì¹˜í™˜ í›„ ì ìš©
        env:
          NAMESPACE: ${{ env.NAMESPACE }}

      # 8. Kubernetes ë¦¬ì†ŒìŠ¤ë“¤ ìˆœì„œëŒ€ë¡œ ë°°í¬
      - name: Deploy to AKS
        run: |
          # í™˜ê²½ë³€ìˆ˜ ì„¤ì • (envsubstì—ì„œ ì‚¬ìš©)
          export IMAGE_NAME="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest"
          export NAMESPACE="${{ env.NAMESPACE }}"
          export APP_NAME="${{ env.IMAGE_NAME }}"
          export REPLICAS="3"                    # íŒŒë“œ ê°œìˆ˜
          export CPU_REQUEST="250m"              # ìµœì†Œ CPU ìš”ì²­ëŸ‰
          export MEMORY_REQUEST="512Mi"          # ìµœì†Œ ë©”ëª¨ë¦¬ ìš”ì²­ëŸ‰
          export CPU_LIMIT="500m"                # ìµœëŒ€ CPU ì œí•œ
          export MEMORY_LIMIT="1Gi"              # ìµœëŒ€ ë©”ëª¨ë¦¬ ì œí•œ
          
          echo "ğŸš€ Deploying Multi-Agent Smart Factory to AKS..."
          echo "ğŸ“¦ Image: $IMAGE_NAME"
          echo "ğŸ  Namespace: $NAMESPACE"
          
          # ìˆœì„œëŒ€ë¡œ ë°°í¬
          echo "ğŸ“‹ Creating namespace..."
          envsubst < k8s/namespace.yaml | kubectl apply -f -     # ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ìƒì„±
          
          echo "ğŸ”§ Deploying application..."
          envsubst < k8s/deployment.yaml | kubectl apply -f -    # ì• í”Œë¦¬ì¼€ì´ì…˜ ë°°í¬
          
          echo "ğŸŒ Creating service..."
          envsubst < k8s/service.yaml | kubectl apply -f -       # ì„œë¹„ìŠ¤ ìƒì„±
          
          echo "ğŸŒ Setting up ingress..."
          envsubst < k8s/ingress.yaml | kubectl apply -f -       # ì¸ê·¸ë ˆìŠ¤ ì„¤ì •
          
          echo "ğŸ“ˆ Configuring auto-scaling..."
          envsubst < k8s/hpa.yaml | kubectl apply -f -           # ì˜¤í† ìŠ¤ì¼€ì¼ë§ ì„¤ì •

      # 9. ë°°í¬ ì™„ë£Œê¹Œì§€ ëŒ€ê¸°
      - name: Wait for deployment to be ready
        run: |
          echo "â³ Waiting for deployment to be ready..."
          # ë°°í¬ê°€ ì™„ë£Œë  ë•Œê¹Œì§€ ìµœëŒ€ 10ë¶„ ëŒ€ê¸°
          kubectl rollout status deployment/${{ env.IMAGE_NAME }} -n ${{ env.NAMESPACE }} --timeout=600s
          
          # íŒŒë“œ ìƒíƒœ í™•ì¸
          echo "ğŸ” Checking pod status..."
          kubectl get pods -n ${{ env.NAMESPACE }} -l app=${{ env.IMAGE_NAME }}
          
          # ë°°í¬ ì •ë³´ ìƒì„¸ ì¶œë ¥
          echo "ğŸ“Š Deployment information:"
          kubectl describe deployment/${{ env.IMAGE_NAME }} -n ${{ env.NAMESPACE }}

      - name: Verify deployment
        run: |
          # Check if pods are running
          RUNNING_PODS=$(kubectl get pods -n ${{ env.NAMESPACE }} -l app=${{ env.IMAGE_NAME }} --field-selector=status.phase=Running --no-headers | wc -l)
          TOTAL_PODS=$(kubectl get pods -n ${{ env.NAMESPACE }} -l app=${{ env.IMAGE_NAME }} --no-headers | wc -l)
          
          echo "ğŸƒ Running pods: $RUNNING_PODS/$TOTAL_PODS"
          
          if [ $RUNNING_PODS -eq 0 ]; then
            echo "âŒ No pods are running! Deployment failed."
            kubectl describe pods -n ${{ env.NAMESPACE }} -l app=${{ env.IMAGE_NAME }}
            exit 1
          fi
          
          # Get service information
          echo "ğŸŒ Service information:"
          kubectl get services -n ${{ env.NAMESPACE }}
          
          # Get ingress information
          echo "ğŸŒ Ingress information:"
          kubectl get ingress -n ${{ env.NAMESPACE }}
          
          # Try to get external IP
          EXTERNAL_IP=$(kubectl get service ${{ env.IMAGE_NAME }}-service -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "pending")
          
          if [ "$EXTERNAL_IP" != "pending" ] && [ ! -z "$EXTERNAL_IP" ]; then
            echo "âœ… Deployment successful!"
            echo "ğŸŒ External IP: $EXTERNAL_IP"
            echo "ğŸ”— Access URL: http://$EXTERNAL_IP"
            echo "ğŸ¥ Health Check: http://$EXTERNAL_IP/health"
          else
            echo "âœ… Deployment successful! External IP still being assigned."
            echo "ğŸ“‹ Check status later with: kubectl get services -n ${{ env.NAMESPACE }}"
          fi

  # ==============================================
  # Job 4: í—¬ìŠ¤ì²´í¬ (ë°°í¬ í›„ ì‹¤í–‰)
  # ==============================================
  health-check:
    if: github.ref == 'refs/heads/main'      # main ë¸Œëœì¹˜ì¼ ë•Œë§Œ
    needs: [deploy-to-aks]                   # ë°°í¬ ì™„ë£Œ í›„ ì‹¤í–‰
    runs-on: ubuntu-latest
    steps:
      # 1. ì½”ë“œ ì²´í¬ì•„ì›ƒ
      - uses: actions/checkout@v4

      # 2. Azure ë¡œê·¸ì¸ ë° AKS ì ‘ì† (ë°°í¬ Jobê³¼ ë™ì¼)
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ env.AKS_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --overwrite-existing

      # 3. ì‹¤ì œ í—¬ìŠ¤ì²´í¬ ìˆ˜í–‰
      - name: Health Check
        run: |
          echo "ğŸ¥ Running health checks on AKS deployment..."
          
          # íŒŒë“œ ìƒíƒœ í™•ì¸
          kubectl get pods -n ${{ env.NAMESPACE }} -l app=${{ env.IMAGE_NAME }}
          
          # ìµœê·¼ íŒŒë“œ ë¡œê·¸ ì¶œë ¥ (ë¬¸ì œ ì§„ë‹¨ìš©)
          echo "ğŸ“‹ Recent pod logs:"
          kubectl logs -n ${{ env.NAMESPACE }} -l app=${{ env.IMAGE_NAME }} --tail=20 || true
          
          # ë‚´ë¶€ ì„œë¹„ìŠ¤ í…ŒìŠ¤íŠ¸ (curlë¡œ ping ì—”ë“œí¬ì¸íŠ¸ í˜¸ì¶œ)
          echo "ğŸ” Testing internal service..."
          kubectl run test-pod --rm -i --restart=Never --image=curlimages/curl -- \
            curl -s -o /dev/null -w "%{http_code}" \
            http://${{ env.IMAGE_NAME }}-service.${{ env.NAMESPACE }}.svc.cluster.local/ping || true
          
          echo "âœ… Health check completed!"

  # ==============================================
  # Job 5: ìë™ PR ë¦¬ë·° (í’ˆì§ˆ ê²€ì‚¬ í›„ ì‹¤í–‰)
  # ==============================================
  auto-review:
    needs: [quality-check]                    # í’ˆì§ˆ ê²€ì‚¬ ì™„ë£Œ í›„ ì‹¤í–‰
    if: github.event_name == 'pull_request' && always()  # PRì´ê³  ì• Jobì´ ì‹¤íŒ¨í•´ë„ ì‹¤í–‰
    runs-on: ubuntu-latest
    permissions:
      contents: read                          # ì½”ë“œ ì½ê¸° ê¶Œí•œ
      pull-requests: write                    # PR ëŒ“ê¸€ ì‘ì„± ê¶Œí•œ
    steps:
      # 1. ì½”ë“œ ì²´í¬ì•„ì›ƒ
      - uses: actions/checkout@v4

      # 2. GitHub Scriptë¡œ PR ëŒ“ê¸€ ì‘ì„±
      - name: PR Code Review Comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}  # GitHub API í† í°
          script: |
            const qualityResult = "${{ needs.quality-check.result }}";
            
            // Collect test results
            const testOutputs = {
              total: "${{ needs.quality-check.outputs.total_tests || '0' }}",
              passed: "${{ needs.quality-check.outputs.passed_tests || '0' }}",
              failed: "${{ needs.quality-check.outputs.failed_tests || '0' }}",
              skipped: "${{ needs.quality-check.outputs.skipped_tests || '0' }}",
              coverage: "${{ needs.quality-check.outputs.coverage || 'N/A' }}",
              lintErrors: "${{ needs.quality-check.outputs.lint_errors || '0' }}"
            };

            // Security scan results
            const securityOutputs = {
              highIssues: "${{ needs.quality-check.outputs.high_issues || '0' }}",
              mediumIssues: "${{ needs.quality-check.outputs.medium_issues || '0' }}",
              lowIssues: "${{ needs.quality-check.outputs.low_issues || '0' }}",
              totalIssues: "${{ needs.quality-check.outputs.total_issues || '0' }}"
            };

            let reviewComment = "## ğŸ¤– Multi-Agent Smart Factory Code Review (Kubernetes Ready)\n\n";

            // Overall status summary
            reviewComment += "### ğŸ“Š Overall Test Results:\n";
            const allPassed = qualityResult === 'success';

            if (allPassed) {
              reviewComment += "âœ… **All checks passed** - Ready for AKS deployment!\n";
            } else {
              reviewComment += "âš ï¸ **Some issues found** - Please review before deployment\n";
            }

            // Test results section
            reviewComment += "\n### ğŸ§ª Test Results:\n";

            if (qualityResult === 'success') {
              reviewComment += "âœ… **Quality checks passed**\n";
            } else if (qualityResult === 'failure') {
              reviewComment += "âŒ **Quality checks failed**\n";
            } else {
              reviewComment += "âš ï¸ **Quality check status unknown**\n";
            }

            // Test statistics
            if (testOutputs.total !== '0') {
              reviewComment += `- **Total tests**: ${testOutputs.total}\n`;
              reviewComment += `- **Passed**: ${testOutputs.passed} âœ…\n`;

              if (testOutputs.failed !== '0') {
                reviewComment += `- **Failed**: ${testOutputs.failed} âŒ\n`;
              }

              if (testOutputs.skipped !== '0') {
                reviewComment += `- **Skipped**: ${testOutputs.skipped} â­ï¸\n`;
              }

              if (testOutputs.coverage !== 'N/A') {
                reviewComment += `- **Coverage**: ${testOutputs.coverage}%\n`;
              }
            } else {
              reviewComment += "- No tests found\n";
            }

            // Lint results
            if (testOutputs.lintErrors !== '0') {
              reviewComment += `- **Lint errors**: ${testOutputs.lintErrors} âŒ\n`;
            } else {
              reviewComment += "- **Lint check**: Passed âœ…\n";
            }

            // Security scan results section
            reviewComment += "\n### ğŸ”’ Security Scan Results:\n";

            if (securityOutputs.totalIssues !== '0') {
              reviewComment += `- **Total security issues**: ${securityOutputs.totalIssues}\n`;

              if (securityOutputs.highIssues !== '0') {
                reviewComment += `  - ğŸ”´ **High**: ${securityOutputs.highIssues}\n`;
              }
              if (securityOutputs.mediumIssues !== '0') {
                reviewComment += `  - ğŸŸ¡ **Medium**: ${securityOutputs.mediumIssues}\n`;
              }
              if (securityOutputs.lowIssues !== '0') {
                reviewComment += `  - ğŸŸ¢ **Low**: ${securityOutputs.lowIssues}\n`;
              }
            } else {
              reviewComment += "- No security issues found âœ…\n";
            }

            // Kubernetes deployment info
            reviewComment += "\n### ğŸš€ Kubernetes Deployment Info:\n";
            if (allPassed) {
              reviewComment += "- âœ… **All checks passed** - Ready for AKS deployment\n";
              reviewComment += "- ğŸ”„ Auto-deploy to AKS on main branch merge\n";
              reviewComment += "- ğŸ³ Docker image will be pushed to ACR: `${{ env.REGISTRY }}`\n";
              reviewComment += "- â˜¸ï¸ Deployment target: `${{ env.AKS_CLUSTER_NAME }}` cluster\n";
              reviewComment += "- ğŸ  Namespace: `${{ env.NAMESPACE }}`\n";
            } else {
              reviewComment += "- âš ï¸ **Checks failed** - Fix issues before AKS deployment\n";
              if (qualityResult !== 'success') {
                reviewComment += "  - ğŸ§ª Code quality issues need resolution\n";
              }
            }

            // Kubernetes features
            reviewComment += "\n### â˜¸ï¸ Kubernetes Features:\n";
            reviewComment += "- **Auto-scaling**: HPA configured for dynamic scaling\n";
            reviewComment += "- **Health checks**: Liveness and readiness probes\n";
            reviewComment += "- **Secrets management**: Secure API key injection\n";
            reviewComment += "- **Service discovery**: Internal service networking\n";
            reviewComment += "- **Ingress**: External access configuration\n";

            // Latest updates info
            reviewComment += "\n### ğŸ” Latest Updates:\n";
            reviewComment += "- **PRESS_HOLE_DETECTION**: New hole detection system\n";
            reviewComment += "- **Bounding Box Analysis**: Statistical analysis based on 6,697 samples\n";
            reviewComment += "- **Issue Codes**: PRESS-HOLE-{SEVERITY}-{HOLE_CLASS}-MISSING-{DATETIME}\n";
            reviewComment += "- **Multi-hole Detection**: PRESS-HOLE-{SEVERITY}-MULTI-MISSING-{DATETIME}\n";

            reviewComment += "\n---\n";
            reviewComment += "*ğŸ¤– This review was automatically generated by GitHub Actions.*\n";
            reviewComment += `*ğŸ“‹ Check detailed logs in [Actions tab](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}).*`;

            try {
              // Check if there's an existing auto-review comment and update it
              const { data: comments } = await github.rest.issues.listComments({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
              });

              const botComment = comments.find(comment => 
                comment.user.type === 'Bot' && 
                comment.body.includes('ğŸ¤– Multi-Agent Smart Factory Code Review')
              );

              if (botComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: reviewComment
                });
                console.log('Updated existing review comment');
              } else {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: reviewComment
                });
                console.log('Created new review comment');
              }

            } catch (error) {
              console.error('Error creating review comment:', error);
              process.exit(0);
            }

  # ==============================================
  # Job 6: ë°°í¬ ì•Œë¦¼ (ëª¨ë“  ë°°í¬ Job ì™„ë£Œ í›„)
  # ==============================================
  notify:
    if: always() && github.ref == 'refs/heads/main'  # main ë¸Œëœì¹˜ì´ê³  í•­ìƒ ì‹¤í–‰
    needs: [build-and-push, deploy-to-aks, health-check]  # ëª¨ë“  ë°°í¬ ê´€ë ¨ Job ì™„ë£Œ í›„
    runs-on: ubuntu-latest
    steps:
      # ë°°í¬ ìƒíƒœì— ë”°ë¥¸ ë©”ì‹œì§€ ì¶œë ¥
      - name: Notify deployment status
        run: |
          if [ "${{ needs.deploy-to-aks.result }}" == "success" ]; then
            # ë°°í¬ ì„±ê³µì‹œ
            echo "âœ… AKS Deployment successful!"
            echo "ğŸ¢ Cluster: ${{ env.AKS_CLUSTER_NAME }}"        # 23-aks
            echo "ğŸ  Namespace: ${{ env.NAMESPACE }}"              # smart-factory
            echo "ğŸ³ Registry: ${{ env.REGISTRY }}"                # 23acr.azurecr.io
            echo "ğŸ” New hole detection system (PRESS_HOLE_DETECTION) deployed"
            echo "ğŸ“Š Analysis system based on 6,697 bounding box data points"
            echo ""
            echo "ğŸ”— Access your application:"
            echo "   kubectl get services -n ${{ env.NAMESPACE }}"
            echo "   kubectl get ingress -n ${{ env.NAMESPACE }}"
          else
            # ë°°í¬ ì‹¤íŒ¨ì‹œ
            echo "âŒ AKS Deployment failed! Please check the logs."
            echo "ğŸ” Debug commands:"
            echo "   kubectl get pods -n ${{ env.NAMESPACE }}"
            echo "   kubectl logs -n ${{ env.NAMESPACE }} -l app=${{ env.IMAGE_NAME }}"
            echo "   kubectl describe deployment/${{ env.IMAGE_NAME }} -n ${{ env.NAMESPACE }}"
          fi